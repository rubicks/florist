#!/bin/sh

# florist/upstream2deb

set -euvx

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${here}").$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

readonly default_distribution="xenial"
readonly default_ros_distro="kinetic"
readonly default_upstream_treeish="HEAD"

log() { echo "${whatami}[$$]: $@" >&2; }
info() { log "INFO: $@"; }
warning() { log "WARNING: $@"; }
error() { log "ERROR: $@"; }

usage() {
    cat <<EOF
Usage: $(basename ${this}) [OPTION]... UPSTREAM_URI
Bloom, build, and package the given UPSTREAM_URI.

Options
    -h                          print this usage and return success
    -f                          force re-blooming extant release repository
    -C RELEASE_BARE             bloom into RELEASE_BARE (default: \$(basename -s .git \${UPSTREAM_URI})-release.git)
    -R ROS_DISTRO               bloom for ROS_DISTRO (default: ${default_ros_distro})
    -b UPSTREAM_DEVEL_BRANCH    upstream devel branch (default: \${ROS_DISTRO}-devel)
    -t UPSTREAM_TREEISH         git treeish (on devel branch) to bloom (default: ${default_upstream_treeish})
    -D DISTRIBUTION             ubuntu distribution codename (default: ${default_distribution})
    -V NEW_VERSION              override the bloom-release version

Examples:

    \$ ./$(basename ${this}) -b demo-dev-vision git@github.com:RealtimeRobotics/rapidplan.git

    \$ ./$(basename ${this}) -b demo-dev-vision -t HEAD git@github.com:RealtimeRobotics/rapidplan.git

    \$ ./$(basename ${this}) -b demo-dev-vision -t HEAD -R kinetic git@github.com:RealtimeRobotics/rapidplan.git

EOF
}

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    status="$?"
    rm -rf "${tmpdir}"
    if command -v docker >&2; then
        docker system prune --force --filter until=6h >&2 || true
    fi
    return "${status}"
}

ends_with() { [ "${1}" != "${1%${2}}" ]; }

is_good_release_bare() {
    test -d "$(readlink -f "$1")"
}

# * it must only consist of alphanumerics and _ separators. Other symbols might
#   not be supported by some OSes (e.g. unicode characters) or would make it
#   hard to follow OSes conventions
#
# * they must be at least two characters long and must start with an alphabetic
#   character. This rule is simply to force the name of the package to be more
#   human understandable.
#
# -- http://www.ros.org/reps/rep-0144.html#mandatory-rules
is_good_package_name() { echo "$1" | grep -Eq '^[[:alpha:]][[:alnum:]_]+$'; }

# $1 : bare git repository
# $2 : destination directory
# rest : git clone args
safe_git_clone() {
    src="$1"
    dst="$2"
    shift 2
    if [ -d "${dst}" ]; then
        warning "exists: ${dst}"
    else
        mkdir -vp "${dst}"
    fi
    if git clone $@ "${src}" "${dst}"; then
        return 0
    fi
    warning "failure: git clone $@ ${src} ${dst}"
    if ! extant_remote="$(git -C ${dst} config --get remote.origin.url)"; then
        error "failure: git -C ${dst} config --get remote.origin.url"
        return 1
    fi
    if ! [ "${src}" = "${extant_remote}" ]; then
        error "bad remote: need ${src}, have ${extant_remote}"
        return 1
    fi
    if ! git -C "${dst}" fetch --verbose --all; then
        error "failure: git -C ${dst} fetch --verbose --all"
        return 1
    fi
    if ! git -C "${dst}" submodule update --init --recursive; then
        error "failure: git -C ${dst} submodule update --init --recursive"
        return 1
    fi
    warning "will use existing clone: ${dst}"
    return 0
}

is_sha1() { echo "$1" | grep -Eq "^[[:xdigit:]]{40}$"; }

# $1 : git checkout path
# $2 : git branch name
# $3 : git treeish
hashify_checkout() {
    if is_sha1 "$3"; then
        if ! git -C "$1" log --pretty=oneline "remotes/origin/$2" | grep -Eq "^$3 "; then
            die "branch origin/$2 missing hash $3"
        fi
        echo "$3"
    elif [ "HEAD" = "$3" ]; then
        git -C "$1" rev-parse "remotes/origin/$2"
    else
        git -C "$1" rev-parse "$3"
    fi
}

# $1 : git remote
# $2 : upstream_devel_branch
# $3 : upstream_treeish
hashify() {
    local checkout_dir=""
    if [ -d "$1" ]; then
        case "$(git -C "$1" rev-parse --is-bare-repository)" in
            true)
                checkout_dir="$(mktemp -dt hashify_checkout_dir.XXXXXX)"
                git clone "$1" "${checkout_dir}"
                ;;
            false)
                checkout_dir="$1"
                ;;
            *)
                error "failure: git -C $1 rev-parse --is-bare-repository"
                return 1
                ;;
        esac
    else
        checkout_dir="$(mktemp -dt hashify_checkout_dir.XXXXXX)"
        git clone "$1" "${checkout_dir}"
    fi
    hashify_checkout "${checkout_dir}" "$2" "$3"
}

ttcopy() {
    tar -C "$1" -cf- . | tar -C "${2:-${PWD}}" -xf-
}

# Print a sha1 for the current state of the checkout.
#
# When there are uncommitted changes, `git stash create` will make a commit
# object (without storing it) and print it. When there are no uncommitted
# changes, `git stash create` will print an empty string and succeed; in this
# case we want get sha1sum of the HEAD. We attempt to print both, but take only
# the first.
#
# $1 : git checkout directory
get_vcs_ref() {
    (
        git -C "$1" stash create
        git -C "$1" rev-parse HEAD
    ) | head -1
}

# Copy given git checkout directory into optional destination directory using
# `git archive`.
#
# reference:
# https://git-scm.com/docs/git-submodule#git-submodule-foreach--recursiveltcommandgt
#
# $1 : git checkout directory
# $2 : target directory (default: $PWD)
gitcopy() {
    git -C "$1" archive "$(get_vcs_ref "$1")" \
        | tar -C "${2:-${PWD}}" -xf-
    git -C "$1" submodule foreach --recursive --quiet \
        "git archive --prefix=\${sm_path}/ \${sha1} | tar -C ${2:-${PWD}} -xf-"
}

# Copy given source directory contents into optional destination directory. If
# `git` is present and source directory is a git checkout, then use `gitcopy`;
# else use `ttcopy`.
#
# $1 : source directory
# $2 : target directory (default: $PWD)
dircopy() {
    if command -v git >/dev/null 2>&1; then
        if git -C "$1" status >/dev/null 2>&1; then
            gitcopy "$1" "${2:-${PWD}}"
            return "$?"
        fi
    fi
    ttcopy "$1" "${2:-${PWD}}"
}

grep_deb_version() {
    echo $@ | grep -Eo '[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+-[[:digit:]]+-g[[:xdigit:]]{7}'
}

grep_ros_version() {
    echo $@ | grep -Eo '[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+'
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":hfC:R:b:t:D:V:" opt; do
    case "${opt}" in
        h)
            usage
            exit "$?"
            ;;
        f) readonly force_bloom="true" ;;
        C)
            if ! [ -d "$(readlink -f "${OPTARG}")" ]; then
                die "not a directory: ${OPTARG}"
            fi
            readonly release_bare="$(readlink -f "${OPTARG}")"
            ;;
        R) readonly ros_distro="${OPTARG}" ;;
        b) readonly upstream_devel_branch="${OPTARG}" ;;
        t) readonly upstream_treeish="${OPTARG}" ;;
        D) readonly distribution="${OPTARG}" ;;
        V) readonly new_version="${OPTARG}" ;;
        :) die "Missing argument: -${OPTARG}" ;;
        \?) die "Invalid option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

####################
# BLOOM ARGS BEGIN #
####################
[ 1 -eq "$#" ] || die "bad args"
readonly upstream_uri="$1"
ends_with "${upstream_uri}" '.git' || die "missing .git suffix: ${upstream_uri}"

readonly package_name="$(basename "$1" .git)"
if is_good_package_name "${package_name}"; then
    info "good package_name: ${package_name}"
else
    die "bad package name: ${package_name}"
fi

if [ -n "${ros_distro:-}" ]; then
    info "ros_distro: ${ros_distro}"
else
    readonly ros_distro="${default_ros_distro}"
    warning "defaulting ros_distro: ${ros_distro}"
fi

if [ -n "${upstream_devel_branch:-}" ]; then
    info "upstream_devel_branch: ${upstream_devel_branch}"
else
    readonly upstream_devel_branch="${default_ros_distro}-devel"
    warning "defaulting upstream_devel_branch: ${upstream_devel_branch}"
fi

if [ -n "${upstream_treeish:-}" ]; then
    info "upstream_treeish: ${upstream_treeish}"
else
    readonly upstream_treeish="${default_upstream_treeish}"
    warning "defaulting upstream_treeish: ${upstream_treeish}"
fi

# release_bare
if [ -n "${release_bare:-}" ]; then
    info "given release_bare: ${release_bare}"
else
    readonly release_bare="${PWD}/${package_name}-release.git"
    warning "defaulting release_bare: ${release_bare}"
fi

##################
# BLOOM ARGS END #
##################

# clone upstream into local (non-bare) checkout
readonly upstream_checkout="${PWD}/${package_name}.checkout"
safe_git_clone \
    "${upstream_uri}" "${upstream_checkout}" \
    --recursive \
    --branch "${upstream_devel_branch}"

# discover the upstream sha1
if ! upstream_sha1="$(hashify "${upstream_checkout}" "${upstream_devel_branch}" "${upstream_treeish}")"; then
    die "failure: hashify ${upstream_checkout} ${upstream_devel_branch} ${upstream_treeish}"
fi
readonly upstream_sha1="${upstream_sha1}"

git -C "${upstream_checkout}" checkout "${upstream_sha1}"
git -C "${upstream_checkout}" submodule update --init --recursive

# vet new_version
if [ -n "${new_version:-}" ]; then
    info "new_version: ${new_version}"
else
    if ! new_version="$(git -C "${upstream_checkout}" describe --long "${upstream_sha1}")"; then
        die "failure: git -C ${upstream_checkout} describe --long ${upstream_sha1}"
    fi
    if ! new_version="$(grep_deb_version "${new_version}")"; then
        die "failure: bad version string"
    fi
    readonly new_version="${new_version}"
    if ! [ -n "${new_version}" ]; then
        die "empty new_version"
    fi
    warning "defaulting new_version: ${new_version}"
fi

# vet distribution
if [ -n "${distribution:-}" ]; then
    info "distribution: ${distribution}"
else
    readonly distribution="${default_distribution}"
    warning "defaulting distribution: ${distribution}"
fi

# > The upstream repository is the repository where you do your development
# > and host the source code of your package. This repository can be hosted
# > anywhere (even locally) and can be a git, hg, or svn repository or the
# > location of an archive (tar.gz only for now, but there are plans for
# > tar.bz and zip).
#
# --- http://wiki.ros.org/bloom/Tutorials/FirstTimeRelease#Preparing_for_Release
readonly orig_tarball="${PWD}/${package_name}_${new_version}.orig.tar.gz"
rm -vf "${orig_tarball}" "${orig_tarball%.*}"
(
    cd "$(mktemp -dt "${package_name}.gitcopy.XXXXXX")"
    gitcopy "${upstream_checkout}" .
    # http://www.etalabs.net/sh_tricks.html
    find . ! -type d \
        | sort \
        | sed 's/./\\&/g' \
        | xargs tar -rf "${orig_tarball%.*}"
)
gzip "${orig_tarball%.*}"

do_bloom() {
    mkdir -vp "${release_bare}"
    info "$(git -C "${release_bare}" init)"
    "${here}/tarball2bloom" \
        -C "${release_bare}" \
        -R "${ros_distro}" \
        -P "${package_name}" \
        -V "$(grep_ros_version "${new_version}")" \
        "${orig_tarball}"
}

if [ -d "${release_bare}" ]; then
    warning "extant release_bare: ${release_bare}"
    if [ "true" = "${force_bloom:-false}" ]; then
        warning "forcing bloom as requested"
        find "${release_bare}" -mindepth 1 -delete
        do_bloom
    else
        warning "skipping bloom"
    fi
else
    do_bloom
fi

readonly release_dir="${release_bare%.git}.dir"
mkdir -vp "${release_dir}"
safe_git_clone "${release_bare}" "${release_dir}"

readonly branch_list="${release_dir%.dir}.branch.list"
git -C "${release_dir}" branch -a >"${branch_list}"

# > [a package name] must only consist of alphanumerics and _ separators
#
# -- http://www.ros.org/reps/rep-0144.html#mandatory-rules
#
# ..._*BUT*_ catkin will happily build packages with hyphens, too.
sed -nri "s|^  remotes/origin/(debian/${ros_distro}/${distribution}/[[:alnum:]_-]+)$|\1|gp" "${branch_list}"
sort -uo "${branch_list}" "${branch_list}"

# uncomment this to avoid "*_example" subprojects
#sed -ri '/.*_examples$/d' "${branch_list}"

# create dependency list, topo sort, and reverse topo sort
"${here}/rosdeps" -C "${upstream_checkout}" >rosdeps.out
tsort <rosdeps.out >tsort.rosdeps.out
tac <tsort.rosdeps.out >tac.tsort.rosdeps.out

# `bloom2deb` creates a file-local apt repository with `Packages` and `Sources`
# files in the current working directory.
touch Packages Sources
while read package; do
    dpkg_name="$(echo "ros-${ros_distro}-${package}" | tr '_' '-')"
    if ! branch_name="$(grep -E "${package}\$" <"${branch_list}")"; then
        die "package missing branch: ${package}"
    fi
    sed -nr 's/^(Package|Version): (.*)$/\2/gp' Packages | xargs -L2 >packages.list
    sed -nr 's/^(Package|Version): (.*)$/\2/gp' Sources | xargs -L2 >sources.list
    if extant_package="$(grep "^${dpkg_name} ${new_version}$" packages.list)"; then
        info "extant package: ${extant_package}"
    fi
    if extant_source="$(grep "^${dpkg_name} ${new_version}$" sources.list)"; then
        info "extant source: ${extant_source}"
    fi
    if [ -n "${extant_package:-}" ] && [ -n "${extant_source:-}" ]; then
        warning "skipping bloom2deb: ${dpkg_name} ${new_version}"
        continue
    fi
    info "starting bloom2deb: ${dpkg_name} ${new_version}"
    git -C "${release_dir}" checkout "${branch_name}"
    # this is where we override the bloom-release version
    "${here}/bloom2deb" -C "${release_dir}" -V "${new_version}"
    info "SUCCESS: BUILT branch ${branch_name}, version ${new_version}"
done <tac.tsort.rosdeps.out

info "SUCCESS: PACKAGED ${upstream_checkout}"
info "new_version           : ${new_version}"
info "release_bare          : ${release_bare}"
info "ros_distro            : ${ros_distro}"
info "upstream_devel_branch : ${upstream_devel_branch}"
info "upstream_sha1         : ${upstream_sha1}"
info "upstream_treeish      : ${upstream_treeish}"
info "upstream_uri          : ${upstream_uri}"

exit "$?"
